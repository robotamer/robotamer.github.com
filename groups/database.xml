<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Database on RoboTamer </title>
    <link>http://localhost:1313/groups/database.xml</link>
    <language>en-us</language>
    <author>Dennis T Kaplan</author>
    <rights>Copyright (c) 2008 - 2013, Dennis T Kaplan; all rights reserved.</rights>
    <updated>2012-01-11 14:00:29 &#43;0000 &#43;0000</updated>
    
    <item>
      <title>rtdb.py: Extension for dtuple.py</title>
      <link>http://localhost:1313/blog/rtdb-py-extension-for-dtuple-py-by-greg-stein/html</link>
      <pubDate>Wed, 11 Jan 2012 14:00:29 &#43;0000</pubDate>
      <author>Steve Francia</author>
      <guid>http://localhost:1313/blog/rtdb-py-extension-for-dtuple-py-by-greg-stein/html</guid>
      <description>&lt;p&gt;This is specific to sqlite but could easily be adopted to work with other databases.&lt;/p&gt;

&lt;p&gt;&amp;lt;!&amp;ndash; more &amp;ndash;&amp;gt;
#&lt;/p&gt;

&lt;h1&gt;rtdb.py: Extension for dtuple.py&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Written by Dennis T Kaplan . Public Domain.&lt;/h1&gt;

&lt;h1&gt;No Copyright, no Rights Reserved, and no Warranties.&lt;/h1&gt;

&lt;p&gt;class rtdb:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, dbname, sql, one = True):
self.one = one
connection = sqlite3.connect(dbname)
cursor = connection.cursor()
cursor.execute(sql)
if one == True:
self._descriptor = dtuple.TupleDescriptor(cursor.description)
self._rows = cursor.fetchone()
else:
self._descriptor = dtuple.TupleDescriptor([[f][0] for f in cursor.description])
self._rows = cursor.fetchall()&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getitem&lt;/strong&gt;(self, index):
if self.one == True:
return dtuple.DatabaseTuple(self._descriptor, self._rows)
else:
return dtuple.DatabaseTuple(self._descriptor, self._rows[index])&lt;/p&gt;

&lt;p&gt;
#&lt;/p&gt;

&lt;h1&gt;dtuple.py: Database Tuple handling&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Written by Greg Stein. Public Domain.&lt;/h1&gt;

&lt;h1&gt;No Copyright, no Rights Reserved, and no Warranties.&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;This module is maintained by Greg and is available at:&lt;/h1&gt;

&lt;h1&gt;&lt;a href=&#34;http://www.lyra.org/greg/python/dtuple.py&#34;&gt;http://www.lyra.org/greg/python/dtuple.py&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Since this isn&amp;rsquo;t in any Python distribution yet, we&amp;rsquo;ll use the CVS ID for&lt;/h1&gt;

&lt;h1&gt;tracking:&lt;/h1&gt;

&lt;h1&gt;$Id: dtuple.py,v 1.1 2000/04/18 20:17:20 gstein Exp $&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;class TupleDescriptor:
&amp;ldquo;&amp;rdquo;&amp;ldquo;Describes a return tuple from a DB-API fetch*() method.&lt;/p&gt;

&lt;p&gt;Instances of this class are used to describe database tuples (which are
typically instances of DatabaseTuple or one of its derivative classes).
These instances specify the column names, formats, lengths, and other
relevant information about the items in a particular tuple. An instance
is typically shared between many database tuples (such as those returned
by a single query).&lt;/p&gt;

&lt;p&gt;Note: the term database tuple is rather specific; in actuality the tuple
may have come from non-database sources and/or generated by a process
wholly unrelated to databases.&lt;/p&gt;

&lt;p&gt;Note again: I&amp;rsquo;m open for new names for this and the DatabaseTuple class
and concept :-)
&amp;ldquo;&amp;rdquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, desc):
&amp;ldquo;&amp;rdquo;&amp;ldquo;TupleDescriptor constructor.&lt;/p&gt;

&lt;p&gt;An instance is created by passing a &amp;ldquo;descriptor&amp;rdquo; to fully specify the
information about the related database tuple. This descriptor takes the
form of a tuple or list where each element is a tuple. The first element
of this tuple is the name of the column. The following elements of the
tuple are used to describe the column (such as length, format,
significant
digits, etc).
&amp;ldquo;&amp;rdquo;&amp;rdquo;
self.desc = tuple(desc)&lt;/p&gt;

&lt;h3&gt;validate the names?&lt;/h3&gt;

&lt;p&gt;self.names = map(lambda x: x[0], desc)
self.namemap = { }
for i in range(len(self.names)):
self.namemap[self.names[i]] = i&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;len&lt;/strong&gt;(self):
&amp;ldquo;&amp;rdquo;&amp;ldquo;Returns the number of elements in the data object.&lt;/p&gt;

&lt;p&gt;A tuple descriptor responds to &lt;strong&gt;len&lt;/strong&gt; to simplify some processing by
allowing the use of the len() builtin function.
&amp;ldquo;&amp;rdquo;&amp;rdquo;
return len(self.names)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;repr&lt;/strong&gt;(self):
return &amp;lsquo;%s(%s)&amp;rsquo; % (self.&lt;strong&gt;class&lt;/strong&gt;.&lt;strong&gt;name&lt;/strong&gt;, repr(self.desc))
def &lt;strong&gt;str&lt;/strong&gt;(self):
return str(self.desc)&lt;/p&gt;

&lt;p&gt;class DatabaseTuple:
&amp;ldquo;&amp;rdquo;&amp;ldquo;Wraps the return data from a DB-API fetch*() method.&lt;/p&gt;

&lt;p&gt;Instances of this class are used to represent tuples of information,
typically returned by a database query. A TupleDescriptor is used as
a means of describing the information for a variety of access methods.
The tuple&amp;rsquo;s information can be accessed via simple indexing, slices,
as a mapping where the keys are the column names (as defined by the
descriptor), or via attribute-based access (where the attribute names
are equivalent to the column names).&lt;/p&gt;

&lt;p&gt;This object acts as a tuple, a list, a mapping, and an instance. To
retrieve &amp;ldquo;pure&amp;rdquo; tuples, lists, or mappings, the asTuple(), asList(),
and asMapping() methods may be used, each returning a value equal to
what this object pretends to be.&lt;/p&gt;

&lt;p&gt;There exists a potential ambiguity between attempting to act as a list
or mapping and the attribute-based access to the data. In particular,
if the column names are &amp;lsquo;index&amp;rsquo;, &amp;lsquo;count&amp;rsquo;, &amp;lsquo;keys&amp;rsquo;, &amp;lsquo;items&amp;rsquo;, &amp;lsquo;values&amp;rsquo;, or
&amp;lsquo;has_key&amp;rsquo;, then the attribute-based access will have precedence over
their related methods for lists and mappings. To actually use these
methods, simply apply them to the result of the asList() or asMapping()
methods.&lt;/p&gt;

&lt;p&gt;Note that column names with leading underscores may interfere with
the implementation of this class, and as a result may not be accessible
via the attribute-access scheme. Also, column names of asTuple, asList,
and asMapping will be inaccessible via the attribute-access scheme
since those will always represent the methods. To access these columns,
the mapping interface can be used with the column name as the mapping
key.&lt;/p&gt;

&lt;p&gt;Note that a database tuple acts as a tuple with respect to sub-scripted
assignment. TypeError exceptions will be raised for several situations,
and AttributeError may be raised for some methods that are intended
to mutate the data (list&amp;rsquo;s &amp;lsquo;sort&amp;rsquo; method) as these methods have not
been implemented.
&amp;ldquo;&amp;rdquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, desc, data):
&amp;ldquo;&amp;rdquo;&amp;ldquo;DatabaseTuple constructor.&lt;/p&gt;

&lt;p&gt;A DatabaseTuple is initialized with a TupleDescriptor and a tuple or
list specifying the data elements.
&amp;ldquo;&amp;rdquo;&amp;rdquo;
if len(desc) != len(data):
raise ValueError # descriptor does not seem to describe tuple
if type(desc) == type(()) or type(desc) == type([]):
desc = TupleDescriptor(desc)
self.&lt;strong&gt;dict&lt;/strong&gt;[&amp;rsquo;&lt;em&gt;desc&lt;/em&gt;&amp;rsquo;] = desc
self.&lt;strong&gt;dict&lt;/strong&gt;[&amp;rsquo;&lt;em&gt;data&lt;/em&gt;&amp;rsquo;] = tuple(data)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;str&lt;/strong&gt;(self):
return str(self.&lt;em&gt;data&lt;/em&gt;)
def &lt;strong&gt;repr&lt;/strong&gt;(self):
return &amp;lsquo;%s(%s,%s)&amp;rsquo; % (self.&lt;strong&gt;class&lt;/strong&gt;.&lt;strong&gt;name&lt;/strong&gt;,
repr(self.&lt;em&gt;desc&lt;/em&gt;),
repr(self.&lt;em&gt;data&lt;/em&gt;))&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;cmp&lt;/strong&gt;(self, other):
if type(self.&lt;em&gt;data&lt;/em&gt;) == type(other):
return cmp(self.&lt;em&gt;data&lt;/em&gt;, other)
if type(self.&lt;em&gt;data&lt;/em&gt;) == type( {} ):
return cmp(self.asMapping(), other)
if type(self.&lt;em&gt;data&lt;/em&gt;) == type( () ):
return cmp(self.asTuple(), other)
if type(self) == type(other): ### fix this: need to verify equal classes
return cmp(self.&lt;em&gt;data&lt;/em&gt;, other.&lt;em&gt;data&lt;/em&gt;)
return cmp(self.&lt;em&gt;data&lt;/em&gt;, other)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getattr&lt;/strong&gt;(self, name):
&amp;lsquo;Simulate attribute-access via column names&amp;rsquo;
return self.&lt;em&gt;getvalue&lt;/em&gt;(name)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;setattr&lt;/strong&gt;(self, name, value):
&amp;lsquo;Simulate attribute-access via column names&amp;rsquo;&lt;/p&gt;

&lt;h3&gt;need to redirect into a db update&lt;/h3&gt;

&lt;p&gt;raise TypeError, &amp;ldquo;can&amp;rsquo;t assign to this subscripted object&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getitem&lt;/strong&gt;(self, key):
&amp;lsquo;Simulate indexed (tuple/list) and mapping-style access&amp;rsquo;
if type(key) == type(1):
return self.&lt;em&gt;data&lt;/em&gt;[key]
return self.&lt;em&gt;getvalue&lt;/em&gt;(key)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;setitem&lt;/strong&gt;(self, key, value):
&amp;lsquo;Simulate indexed (tuple/list) and mapping-style access&amp;rsquo;
if type(key) == type(1):&lt;/p&gt;

&lt;h3&gt;need to redirect into a db update of elem #key&lt;/h3&gt;

&lt;p&gt;raise TypeError, &amp;ldquo;can&amp;rsquo;t assign to this subscripted object&amp;rdquo;&lt;/p&gt;

&lt;h3&gt;need to redirect into a db update of elem named key&lt;/h3&gt;

&lt;p&gt;raise TypeError, &amp;ldquo;can&amp;rsquo;t assign to this subscripted object&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;len&lt;/strong&gt;(self):
return len(self.&lt;em&gt;data&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getslice&lt;/strong&gt;(self, i, j):
&amp;lsquo;Simulate list/tuple slicing access&amp;rsquo;
return self.&lt;em&gt;data&lt;/em&gt;[i:j]&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;setslice&lt;/strong&gt;(self, i, j, list):
&amp;lsquo;Simulate list/tuple slicing access&amp;rsquo;&lt;/p&gt;

&lt;h3&gt;need to redirect into a db update of elems&lt;/h3&gt;

&lt;p&gt;raise TypeError, &amp;ldquo;can&amp;rsquo;t assign to this subscripted object&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;keys&lt;/em&gt;(self):
&amp;ldquo;Simulate mapping&amp;rsquo;s methods&amp;rdquo;
return self.&lt;em&gt;desc&lt;/em&gt;.names&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;has_key&lt;/em&gt;(self, key):
&amp;ldquo;Simulate mapping&amp;rsquo;s methods&amp;rdquo;
return key in self.&lt;em&gt;desc&lt;/em&gt;.names&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;items&lt;/em&gt;(self):
&amp;ldquo;Simulate mapping&amp;rsquo;s methods&amp;rdquo;
return self.asMapping().items()&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;count&lt;/em&gt;(self, item):
&amp;ldquo;Simulate list&amp;rsquo;s methods&amp;rdquo;
return self.asList().count(item)&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;index&lt;/em&gt;(self, item):
&amp;ldquo;Simulate list&amp;rsquo;s methods&amp;rdquo;
return self.asList().index(item)&lt;/p&gt;

&lt;p&gt;def &lt;em&gt;getvalue&lt;/em&gt;(self,name):
&amp;lsquo;Internal method for named-based value retrieval&amp;rsquo;
if name not in self.&lt;em&gt;desc&lt;/em&gt;.names:
if name == &amp;lsquo;keys&amp;rsquo;:
return self.&lt;em&gt;keys&lt;/em&gt;
if name == &amp;lsquo;items&amp;rsquo;:
return self.&lt;em&gt;items&lt;/em&gt;
if name == &amp;lsquo;values&amp;rsquo;:
return self.asList
if name == &amp;lsquo;has&lt;em&gt;key&amp;rsquo;:
return self._has_key&lt;/em&gt;
if name == &amp;lsquo;count&amp;rsquo;:
return self.&lt;em&gt;count&lt;/em&gt;
if name == &amp;lsquo;index&amp;rsquo;:
return self.&lt;em&gt;index&lt;/em&gt;
raise AttributeError
return self.&lt;em&gt;data&lt;/em&gt;[self.&lt;em&gt;desc&lt;/em&gt;.namemap[name]]&lt;/p&gt;

&lt;p&gt;def asMapping(self):
&amp;lsquo;Return the &amp;ldquo;tuple&amp;rdquo; as a real mapping&amp;rsquo;
value = { }
for name, idx in self.&lt;em&gt;desc&lt;/em&gt;.namemap.items():
value[name] = self.&lt;em&gt;data&lt;/em&gt;[idx]
return value&lt;/p&gt;

&lt;p&gt;def asTuple(self):
&amp;lsquo;Return the &amp;ldquo;tuple&amp;rdquo; as a real tuple&amp;rsquo;
return self.&lt;em&gt;data&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;def asList(self):
&amp;lsquo;Return the &amp;ldquo;list&amp;rdquo; as a real mapping&amp;rsquo;
return map(None, self.&lt;em&gt;data&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
